<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络全貌及其通信机制</title>
    <link href="/2022/04/15/InternetConnect/"/>
    <url>/2022/04/15/InternetConnect/</url>
    
    <content type="html"><![CDATA[<h1 id="网络的全貌及其通信机制概括"><a href="#网络的全貌及其通信机制概括" class="headerlink" title="网络的全貌及其通信机制概括"></a>网络的全貌及其通信机制概括</h1><p><img src="/img/blog/NetConnect_1.PNG" alt="NetConnect_1" style="zoom:50%;" /><img src="/img/blog/NetConnect_2.PNG" alt="NetConnect_2" style="zoom:50%;" /></p><p><strong>以上为网络的大概全貌及其通信机制</strong></p><p>接下来将通过将其分解成几部分进行全面的概括以求更好的理解其中的通信机制</p><h2 id="浏览器（浏览器内部）"><a href="#浏览器（浏览器内部）" class="headerlink" title="浏览器（浏览器内部）"></a>浏览器（浏览器内部）</h2><h3 id="输入URL"><a href="#输入URL" class="headerlink" title="输入URL"></a>输入URL</h3><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><p>故事开始与第一次输入URL（Uniform Resource Locator），浏览器会对其进行解析并进行下一步操作。解析的过程包括</p><ol>    <li>识别使用的协议，确定是什么服务器http/ftp/file/mailto等</li>    <li>检查域名的名称以及端口和文件位置或者说文件夹（定位）</li></ol><h3 id="HTTP通信"><a href="#HTTP通信" class="headerlink" title="HTTP通信"></a>HTTP通信</h3><p>解析完成后，应用程序会向服务器发送消息进行通信，这个通过HTTP协议进行通信，基本思路如下</p><p><img src="/img/blog/HTTP.PNG"></p><p>每条请求消息中只能写一个URI，<strong>所以如果要完全解析一个网页要多次进行请求才能解析完成</strong></p><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p><strong>发送</strong>的HTTP协议里面总的大概有<strong>两部分</strong>一部分是<strong>方法</strong>即对要对这个文件要进行什么操作（GET、POST、DELETE等）</p><p><strong>URI</strong>就是另一部分就是对那些文件进行操作：包括有文件或<strong>CGI程序</strong>（<strong>简而言之就是可以被服务器调用的软件</strong>）</p><p>URI：Uniform Resource Identifier，统一资源标识符。</p><p>CGI 程序：对 Web 服务器程序调用其他程序的规则所做的定义就是 CGI， 而按照 CGI 规范来工作的程序就称为 CGI 程序。</p><h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p>当服务器读到应用程序发来的包后就会返回状态码和相应消息</p><h3 id="生成HTTP消息"><a href="#生成HTTP消息" class="headerlink" title="生成HTTP消息"></a>生成HTTP消息</h3><p>上面解释了应用程序和服务器通信的基本流程</p><p>现在说一下应用生成和返回的HTTP消息的<strong>具体内容</strong></p><p><img src="/img/blog/http_inout.PNG"></p><h4 id="返回的的状态码分类如下"><a href="#返回的的状态码分类如下" class="headerlink" title="返回的的状态码分类如下"></a>返回的的状态码分类如下</h4><p><img src="/img/blog/feedback_code.PNG"></p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>在解析URL的时候会对这个域名进行DNS查询然后获得IP地址，以对这个服务器进行通信（因为互联网和局域网都是基于TCP&#x2F;IP的思路进行搭建的）就是由一些 小的子网，通过路由器  连接起来组成一个大的网络。这里的子网可以理解 为用集线器  连接起来的几台计算机 ，我们将它看作一个单位，称为子网。 将子网通过路由器连接起来，就形成了一个网络 </p><h4 id="查询IP（调用解析器进行查询）"><a href="#查询IP（调用解析器进行查询）" class="headerlink" title="查询IP（调用解析器进行查询）"></a>查询IP（调用解析器进行查询）</h4><p><strong><u>IP地址</u><strong>是由一串32比特的数字表示的，分为网络号和主机号，具体位数</strong>不固定</strong>用户可以根据具体情况分配。由此衍生**<u>子网掩码</u><strong>的概念，子网掩码，也是相同的比特数的子组成通过&#x2F;与IP地址区分子网掩码</strong>为一的是网络号<strong>，</strong>为零的是主机号**。这种写法太长，我们也可 以把 1 的部分的比特数用十进制表示并写在 IP 地址的右侧</p><p>还有**<u>端口</u>**，是套接字进行通信的暂时不进行解释</p><p>查询IP地址的话只需要对DNS客户端进行查询就可以了（**<u>解析器</u><strong>）</strong>解析器实际上是一段程序，它包含在操作系统的 Socket 库中**</p><p><strong><u>Socket 库</u>也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能</strong></p><p><img src="/img/blog/jiexiqi.PNG"></p><p>直接返回所需要的IP地址，这样就可以查询到了</p><h4 id="解析器原理"><a href="#解析器原理" class="headerlink" title="解析器原理"></a>解析器原理</h4><img src="/img/blog/jiexiqi_2.PNG" style="zoom:60%;" /><h4 id="DNS服务器的原理"><a href="#DNS服务器的原理" class="headerlink" title="DNS服务器的原理"></a>DNS服务器的原理</h4><p>DNS服务器基本只处理三种消息，1.域名2.类3.记录类型</p><p>DNS是分层储存这些域名信息的根据URL的分级逐级进行分类</p><p>DNS会通过缓存来储存一部分查询的记录以加快查询的速度</p><h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p><strong>操作系统通过协议栈（TCP&#x2F;IP通信）进行数据的交互是最上层HTTP通信的下层</strong></p><p>即HTTP是委托协议栈发送的一种数字信息，数字信息可以有很多种。同样也需要调用Socket库中的组件只不过需要调用多个组件</p><p><strong>收发数据的四个阶段</strong></p><p>（1）创建套接字（创建套接字阶段） （2）将管道连接到服务器端的套接字上（连接阶段） （3）收发数据（通信阶段） （4）断开管道并删除套接字（断开阶段）</p><h4 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h4><p>调用socket组件，会返回一个状态码用于本机进行通信的区分和定位</p><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><p>调用connect组件。这里的要点是当调用 connect 时，需要指定描述符、 服务器 IP 地址和<strong>端口号</strong>这 3 个参数</p><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p>调用write组件。应用程序在内存中准备好数据，调用时通过描述符和要写的数据进行通信，然后服务器进行回显状态码，接受消息是用read组件进行接受</p><h4 id="结束阶段"><a href="#结束阶段" class="headerlink" title="结束阶段"></a>结束阶段</h4><p>当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需 要调用 Socket 库的 close 程序组件进入断开阶段。最终，连接 在套接字之间的管道会被断开，套接字本身也会被删除。</p><p><strong>这就是 HTTP 的工作过程。HTTP 协议将 HTML 文档和图片都作为单 独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、 接收响应消息、断开的过程。因此，如果一个网页中包含很多张图片，就 必须重复进行很多次连接、收发数据、断开的操作。对于同一台服务器来 说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在 一次连接中收发多个请求和响应的方法。在 HTTP 版本 1.1 中就可以使用 这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发 断开连接的操作</strong></p><h2 id="TCP-x2F-IP（协议栈、网卡）"><a href="#TCP-x2F-IP（协议栈、网卡）" class="headerlink" title="TCP&#x2F;IP（协议栈、网卡）"></a>TCP&#x2F;IP（协议栈、网卡）</h2><p>总的结构图如图所示</p><img src="E:\third_test\source\img\blog\TCP_IP.PNG" style="zoom:60%;" /><h3 id="创建套接字-1"><a href="#创建套接字-1" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>套接字的实际意义就是TCP模块的生成的控制信息，它储存在协议栈开辟的内存中。</p><h4 id="套接字信息"><a href="#套接字信息" class="headerlink" title="套接字信息"></a>套接字信息</h4><p>里面包含了协议类型、本地端口、通信地址、通信状态、PID（是操作系统为了标识程序而分配的 编号，使用任务管理器可以查询所对应的程序名称）</p><h4 id="调用scokect时的操作"><a href="#调用scokect时的操作" class="headerlink" title="调用scokect时的操作"></a>调用scokect时的操作</h4><p>调用的时候会在协议栈里面开辟一块内存空间存放套接字信息</p><h3 id="链接服务器"><a href="#链接服务器" class="headerlink" title="链接服务器"></a>链接服务器</h3><h4 id="连接的意思"><a href="#连接的意思" class="headerlink" title="连接的意思"></a>连接的意思</h4><p>两端交换控制信息，并建立链接</p><h4 id="负责保存控制信息的头部"><a href="#负责保存控制信息的头部" class="headerlink" title="负责保存控制信息的头部"></a>负责保存控制信息的头部</h4><p>第一类是客户端和服务器相互联络时交换的控制信息</p><p>第二类是保存在套接字中，用来控制协议栈操 作的信息</p><h4 id="连接操作的实际过程（领悟有来有回定理）"><a href="#连接操作的实际过程（领悟有来有回定理）" class="headerlink" title="连接操作的实际过程（领悟有来有回定理）"></a>连接操作的实际过程（领悟有来有回定理）</h4><p>连接操作的第一步是在 TCP 模块处创建表示连接控制信息的头部，通过 TCP 头部中的发送方和接收方端口号可以找到要连接的套 接字。</p><p>然后就是委托给IP发给服务器进行信息交互，服务器接收到消息之后会返回一个差不多的包反向建立连接</p><p>客户端（发送方）的套接字就准确找到了服务器（接收方）的套接字，也就是搞清楚了我应该连接哪个套接字。然后，我们将头 部中的控制位的 SYN 比特设置为 1，大家可以认为它表示连接，接收到发送端消息的服务器也会将SYN设置为表示连接成功</p><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><h4 id="将HTTP消息交给协议栈"><a href="#将HTTP消息交给协议栈" class="headerlink" title="将HTTP消息交给协议栈"></a>将HTTP消息交给协议栈</h4><p>查看长度并进行分割以便进行收发</p><h4 id="使用序号和ACK进行对传输的帧进行丢帧实验"><a href="#使用序号和ACK进行对传输的帧进行丢帧实验" class="headerlink" title="使用序号和ACK进行对传输的帧进行丢帧实验"></a>使用序号和ACK进行对传输的帧进行丢帧实验</h4><p>首先，TCP 模块在拆分数据时， 会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块 数据时，将算好的字节数写在 TCP 头部中，“序号”字段就是派在这个用 场上的。然后，发送数据的长度也需要告知接收方，不过这个并不是放在 TCP 头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数 据的长度，所以接收方可以用这种方法来进行计算。有了上面两个数值， 我们就可以知道发送的数据是从第几个字节开始，长度是多少了</p><p>通过这些信息，接收方还能够检查收到的网络包有没有遗漏。例如， 假设上次接收到第 1460 字节，那么接下来如果收到序号为 1461 的包，说 明中间没有遗漏；但如果收到的包序号为 2921，那就说明中间有包遗漏 了。像这样，如果确认没有遗漏，接收方会将到目前为止接收到的数据长 度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入 TCP 头部的 ACK 号中发送给发送方 A。简单来说，发送方说的是“现在发送的 是从第 ×× 字节开始的部分，一共有 ×× 字节哦！”而接收方则回复说， “到第 ×× 字节之前的数据我已经都收到了哦！”这个返回 ACK 号的操 作被称为<strong>确认响应</strong>，通过这样的方式，发送方就能够确认对方到底收到 了多少数据</p><h4 id="使用滑动窗口进行帧的传输"><a href="#使用滑动窗口进行帧的传输" class="headerlink" title="使用滑动窗口进行帧的传输"></a>使用滑动窗口进行帧的传输</h4><img src="E:\third_test\source\img\blog\flex.PNG" style="zoom:60%;" /><p>使用的原理是用缓存区对接受的帧进行缓存并处理，之后在返送ACK</p><h4 id="接收-HTTP-响应消息"><a href="#接收-HTTP-响应消息" class="headerlink" title="接收 HTTP 响应消息"></a>接收 HTTP 响应消息</h4><p>浏览器在委托协议栈发送请求消息之后，会调用 read 程序,来获取响应消息。然后，控制流程会通过 read 转移到协议 栈 ，然后协议栈会执行接下来的操作。和发送数据一样，<strong>接收数据也需要 将数据暂存到接收缓冲区中</strong>，这里的操作过程如下。首先，协议栈尝试从 接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送 出去，<strong>响应消息可能还没返回</strong>。响应消息的返回还需要等待一段时间，因 此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这 时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递 给应用程序的工作<strong>暂时挂起</strong> ，等服务器返回的响应消息到达之后再继续执 行接收操作</p><h4 id="数据发送完毕后断开连接"><a href="#数据发送完毕后断开连接" class="headerlink" title="数据发送完毕后断开连接"></a>数据发送完毕后断开连接</h4><p>调用close函数，首先一端先返回FIN码为一然后最后发送ACK码进行ACK码校验，另一端也是先返送FIN为一然后也发送ACK码进行校验，如果有没有接收到的包就继续等待一段时间，然后断开链接</p><h4 id="TCP整体流程"><a href="#TCP整体流程" class="headerlink" title="TCP整体流程"></a>TCP整体流程</h4><img src="/img/blog/tcp.PNG" style="zoom:60%;" /><p>hello <a href="http://example.com/2022/04/15/InternetConnect/">http://example.com/2022/04/15/InternetConnect/</a> bye</p>]]></content>
    
    
    <categories>
      
      <category>base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>InternetBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密编码类型的密文特征分析</title>
    <link href="/2022/04/13/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%86%E6%96%87%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/04/13/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%86%E6%96%87%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="加密编码类型的密文特征分析"><a href="#加密编码类型的密文特征分析" class="headerlink" title="加密编码类型的密文特征分析"></a>加密编码类型的密文特征分析</h1><h2 id="MD5、sha1、HMAC算法、NTLM等相似加密类型（哈希算法型）"><a href="#MD5、sha1、HMAC算法、NTLM等相似加密类型（哈希算法型）" class="headerlink" title="MD5、sha1、HMAC算法、NTLM等相似加密类型（哈希算法型）"></a>MD5、sha1、HMAC算法、NTLM等相似加密类型（哈希算法型）</h2><ol>    <li><b>MD5--示例：17722ac8b4755df0810f793439fe663f</b>        <p>一般MD5 32位的值是由“0-9”和“a-f”组成的三十二位字符串（超出这个范围的就是错误的MD5值就没要拿去解码了）</p>        <p>MD5的特征        <ol>            <li>确定性：一个原始数据的MD5值是唯一的，不会出现多个值</li>            <li>碰撞性：可能多个原始数据的MD5值是相同的，意为碰撞性</li>            <li>不可逆：一个MD5值对应多个原始数据，那理论上来讲可以对应无数个原始数据（即只有MD5值是无法解码出原始数据）</li>        </ol>                </p>    </li>    <li>        <p><b>sha1--示例：f88015758bdf21c6fe1e3fb61ac80f88106c0c8e</b></p>        <p>加密方法和MD5差不多但是密文是<b>40位的</b></p>    </li>    <li>        <p><b>HMAC算法--示例：609a3e3147a19883fcd82bb778ad531e</b></p>    </li></ol><p><img src="/img/blog/HMAC.PNG" alt="HMAC"></p><p>HMAC (Hash-based Message Authentication Code) 常用于接口签名验证，这种算法就是在前两种加密的基础上引入了秘钥，而秘钥又只有传输双方才知道，所以基本上是破解不了的</p><ol start='4'>    <li>NTLM——示例209c6174da490caeb422f3fa5a7ae634        <p>这种加密是Windows的哈希密码，是 Windows NT 早期版本的标准安全协议。与它相同的还有Domain Cached Credentials（域哈希）。        </p>    </li></ol><p>相似加密类型</p><table><thead><tr><th align="left">#</th><th align="center">算法</th><th align="center">长度</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">md5</td><td align="center">32&#x2F;16</td></tr><tr><td align="left">2</td><td align="center">sha1</td><td align="center">40</td></tr><tr><td align="left">3</td><td align="center">sha256</td><td align="center">64</td></tr><tr><td align="left">4</td><td align="center">sha512</td><td align="center">128</td></tr><tr><td align="left">5</td><td align="center">adler32</td><td align="center">8</td></tr><tr><td align="left">6</td><td align="center">crc32</td><td align="center">8</td></tr><tr><td align="left">7</td><td align="center">crc32b</td><td align="center">8</td></tr><tr><td align="left">8</td><td align="center">fnv132</td><td align="center">8</td></tr><tr><td align="left">9</td><td align="center">fnv164</td><td align="center">16</td></tr><tr><td align="left">10</td><td align="center">fnv1a32</td><td align="center">8</td></tr><tr><td align="left">11</td><td align="center">fnv1a64</td><td align="center">16</td></tr><tr><td align="left">12</td><td align="center">gost</td><td align="center">64</td></tr><tr><td align="left">13</td><td align="center">gost-crypto</td><td align="center">64</td></tr><tr><td align="left">14</td><td align="center">haval128,3</td><td align="center">32</td></tr><tr><td align="left">15</td><td align="center">haval128,4</td><td align="center">32</td></tr><tr><td align="left">16</td><td align="center">haval128,5</td><td align="center">32</td></tr><tr><td align="left">17</td><td align="center">haval160,3</td><td align="center">40</td></tr><tr><td align="left">18</td><td align="center">haval160,4</td><td align="center">40</td></tr><tr><td align="left">19</td><td align="center">haval160,5</td><td align="center">40</td></tr><tr><td align="left">20</td><td align="center">haval192,3</td><td align="center">48</td></tr><tr><td align="left">21</td><td align="center">haval192,4</td><td align="center">48</td></tr><tr><td align="left">22</td><td align="center">haval192,5</td><td align="center">48</td></tr><tr><td align="left">23</td><td align="center">haval224,3</td><td align="center">56</td></tr><tr><td align="left">24</td><td align="center">haval224,4</td><td align="center">56</td></tr><tr><td align="left">25</td><td align="center">haval224,5</td><td align="center">56</td></tr><tr><td align="left">26</td><td align="center">haval256,3</td><td align="center">64</td></tr><tr><td align="left">27</td><td align="center">haval256,4</td><td align="center">64</td></tr><tr><td align="left">28</td><td align="center">haval256,5</td><td align="center">64</td></tr><tr><td align="left">29</td><td align="center">joaat</td><td align="center">8</td></tr><tr><td align="left">30</td><td align="center">md2</td><td align="center">32</td></tr><tr><td align="left">31</td><td align="center">md4</td><td align="center">32</td></tr><tr><td align="left">32</td><td align="center">ripemd128</td><td align="center">32</td></tr><tr><td align="left">33</td><td align="center">ripemd160</td><td align="center">40</td></tr><tr><td align="left">34</td><td align="center">ripemd256</td><td align="center">64</td></tr><tr><td align="left">35</td><td align="center">ripemd320</td><td align="center">80</td></tr><tr><td align="left">36</td><td align="center">sha224</td><td align="center">56</td></tr><tr><td align="left">37</td><td align="center">sha3-224</td><td align="center">56</td></tr><tr><td align="left">38</td><td align="center">sha3-256</td><td align="center">64</td></tr><tr><td align="left">39</td><td align="center">sha3-384</td><td align="center">96</td></tr><tr><td align="left">40</td><td align="center">sha3-512</td><td align="center">128</td></tr><tr><td align="left">41</td><td align="center">sha384</td><td align="center">96</td></tr><tr><td align="left">42</td><td align="center">sha512&#x2F;224</td><td align="center">56</td></tr><tr><td align="left">43</td><td align="center">sha512&#x2F;256</td><td align="center">64</td></tr><tr><td align="left">44</td><td align="center">snefru</td><td align="center">64</td></tr><tr><td align="left">45</td><td align="center">snefru256</td><td align="center">64</td></tr><tr><td align="left">46</td><td align="center">tiger128,3</td><td align="center">32</td></tr><tr><td align="left">47</td><td align="center">tiger128,4</td><td align="center">32</td></tr><tr><td align="left">48</td><td align="center">tiger160,3</td><td align="center">40</td></tr><tr><td align="left">49</td><td align="center">tiger160,4</td><td align="center">40</td></tr><tr><td align="left">50</td><td align="center">tiger192,3</td><td align="center">48</td></tr><tr><td align="left">51</td><td align="center">tiger192,4</td><td align="center">48</td></tr><tr><td align="left">52</td><td align="center">whirlpool</td><td align="center">128</td></tr><tr><td align="left">53</td><td align="center">mysql</td><td align="center">老MYSQL数据库用的，16位，且第1位和第7位必须为0-8</td></tr><tr><td align="left">54</td><td align="center">mysql5</td><td align="center">40</td></tr><tr><td align="left">55</td><td align="center">NTLM</td><td align="center">32</td></tr><tr><td align="left">56</td><td align="center">Domain Cached Credentials</td><td align="center">32</td></tr></tbody></table><p>常见解密网站</p><ul>    <li><a href="https://www.cmd5.com/">www.cmd5.com</a></li>    <li><a href="http://www.metools.info/code/">www.metools.info/</a></li></ul><h2 id="Base64、Base58、Base32、Base16、Base85、Base100等相似加密类型（轮盘加密）"><a href="#Base64、Base58、Base32、Base16、Base85、Base100等相似加密类型（轮盘加密）" class="headerlink" title="Base64、Base58、Base32、Base16、Base85、Base100等相似加密类型（轮盘加密）"></a>Base64、Base58、Base32、Base16、Base85、Base100等相似加密类型（轮盘加密）</h2><ol>    <li>Base64--示例：Z29vZA==        <p><b>一般情况下密文尾部都会有两个等号，明文很少的时候则没有</b></p>        <p>Base64编码要求把3个8位字节（38=24）转化为4个6位的字节（46=24），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用‘=’，因此编码后输出的文本末尾可能会出现1或2个‘=’，如图。</p>        <ol>            <li><b>URL传参的问题：</b><p>标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。为解决此问题，可采用一种用于URL的改进Base64编码，它在末尾填充’='号，并将标准Base64中的“+”和“/”分别改成了“-”和“_”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。</p></li>            <li><b>传参问题的改善：</b><p>另有一种用于正则表达式的改进Base64变种，它将“+”和“/”改成了“!”和“-”，因为“+”,“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。                此外还有一些变种，它们将“+/”改为“-”或“.”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“_:”（用于XML中的Name）。</p></li>            <li><b>Base64转换后比原有的字符串长1/3：</b><p>Base64要求把每三个8Bit的字节转换为四个6Bit的字节（38 = 46 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。</p></li>            <li><b>Base64转换总结：</b><p>加密传参尽量不用</p></li>        </ol>    </li>    <li>        <b>Base58——示例6tmHCZvhgfNjQu</b>        <ol>            <li><b>它最大的特点是没有等号：</b><p>Base58是用于比特币（Bitcoin）中使用的一种独特的编码方式，主要用于产生Bitcoin的钱包地址。相比Base64，Base58不使用数字"0"，字母大写"O"，字母大写"I"，和字母小写"l"，以及"+“和”/"符号。比特币的Base58字母表：123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz简单的说：Base58一种编码方式，跟十进制，十六进制一样，不过更短更省空间。</p></li>            <li><b>Base58的原理是什么？</b>                <p>Base58可以理解为一种58进制。Base58包含了阿拉伯数字、小写英文字母，大写英文字母。但是去掉了一些容易混淆的数字和字母：0（数字0）、O（o的大写字母）、l（ L的小写字母）、I（i的大写字母）</p>            </li>        </ol>    </li>    <li><b>Base32——示例GEZDGNBVGY3TQOJQGE======</b>        <p>Base32使用了ASCII编码中可打印的32个字符(大写字母AZ和数字27)对任意字节数据进行编码.Base32将串起来的二进制数据按照5个二进制位分为一组，由于传输数据的单位是字节(即8个二进制位).所以分割之前的二进制位数是40的倍数(40是5和8的最小公倍数).如果不足40位，则在编码后数据补充"="，一个"="相当于一个组(5个二进制位)，编码后的数据是原先的8/5倍.Base32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个。</p>    </li>    <li><b>Base16——示例61646D696E</b>        <p><b>它的特点是没有等号并且数字要多于字母</b></p>        <p>Base16编码的方式：1.将数据(根据ASCII编码，UTF-8编码等)转成对应的二进制数，不足8比特位高位补0。然后将所有的二进制全部串起来，4个二进制位为一组，转化成对应十进制数。2.根据十进制数值找到Base16编码表里面对应的字符。Base16是4个比特位表示一个字符，所以原始是1个字节(8个比特位)刚好可以分成两组,也就是说原先如果使用ASCII编码后的一个字符，现在转化成两个字符。数据量是原先的2倍。</p>    </li>    <li><b>Base85——示例@:X4hDWe0rkE(G[OdP4CT]N#</b>        <p><b>特点是奇怪的字符比较多，但是很难出现等号</b></p>    </li>    <li><b>Base100——示例👘👛👤👠👥</b>        <p><b>特点就是一堆Emoji表情</b></p>    </li></ol><p><b>常用网站</b></p><ul>    <li><a href="https://base64.us/">base64</a></li>    <li><a href="http://www.metools.info/code/c74.html">base58</a></li>    <li><a href="https://www.qqxiuzi.cn/bianma/base.php">base32/16</a></li>    <li><a href="http://www.atoolbox.net/Tool.php?Id=936">base100</a></li></ul><h2 id="AES、DES、RC4、Rabbit、Triple-DES（3DES）"><a href="#AES、DES、RC4、Rabbit、Triple-DES（3DES）" class="headerlink" title="AES、DES、RC4、Rabbit、Triple DES（3DES）"></a>AES、DES、RC4、Rabbit、Triple DES（3DES）</h2><p>这些都是非对称性加密算法，就是引入了密钥，密文特征与Base64类似</p><h2 id="Unicode、HTML实体编码、16进制Unicode"><a href="#Unicode、HTML实体编码、16进制Unicode" class="headerlink" title="Unicode、HTML实体编码、16进制Unicode"></a>Unicode、HTML实体编码、16进制Unicode</h2><h3 id="1-Unicode——汉字示例、字母示例、数字符号示例"><a href="#1-Unicode——汉字示例、字母示例、数字符号示例" class="headerlink" title="1.Unicode——汉字示例、字母示例、数字符号示例"></a>1.Unicode——汉字示例、字母示例、数字符号示例</h3><p><b>可以说Unicode与HTML实体编码是一个东西</b></p><p>Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</p><h3 id="2、HTML实体编码——示例与Unicode相同"><a href="#2、HTML实体编码——示例与Unicode相同" class="headerlink" title="2、HTML实体编码——示例与Unicode相同"></a>2、HTML实体编码——示例与Unicode相同</h3><p>    字符实体是用一个编号写入HTML代码中来代替一个字符，在使用浏览器访问网页时会将这个编号解析还原为字符以供阅读。</p><p>这么做的目的主要有两个：１、解决HTML代码编写中的一些问题。例如需要在网页上显示小于号（<）和大于号（>），由于它们是HTML的预留标签，可能会被误解析。这时就需要将小于号和大于号写成字符实体：小于号这样写：< 或 <大于号这样写：> 或 >前面的写法称为实体名称，后面的写法则是实体编号。ISO-8859-1字符集（西欧语言）中两百多个字符设定了实体名称，而对于其它所有字符都可以用实体编号来代替。２、网页编码采用了特定语言的编码，却需要显示来自其它语言的字符。例如，网页编码采用了西欧语言ISO-8859-1，却要在网页中显示中文，这时必须将中文字符以实体形式写入HTML代码中。</p><h3 id="3、16进制Unicode——示例-u8fd9-u662f-u4e00"><a href="#3、16进制Unicode——示例-u8fd9-u662f-u4e00" class="headerlink" title="3、16进制Unicode——示例\u8fd9\u662f\u4e00"></a>3、16进制Unicode——示例<code>\u8fd9\u662f\u4e00</code></h3><p><img src="/img/blog/c9ozt8bjbv.png"></p><ul>    <li><a href="https://www.sojson.com/unicode.html">Unicode</a></li>    <li><a href="http://www.msxindl.com/tools/unicode16.asp">16进制Unicode</li>    <li><a href="https://www.qqxiuzi.cn/bianma/zifushiti.php">HTML字符实体</a></li></ul><h2 id="Escape编码-x2F-加密、Unescape解码-x2F-解密、-u编码、-u解码"><a href="#Escape编码-x2F-加密、Unescape解码-x2F-解密、-u编码、-u解码" class="headerlink" title="Escape编码&#x2F;加密、Unescape解码&#x2F;解密、%u编码、%u解码"></a>Escape编码&#x2F;加密、Unescape解码&#x2F;解密、%u编码、%u解码</h2><p><b>特征：以`%u`开头</b></p><p>    <b>Escape/Unescape加密解码/编码解码,又叫%u编码</b>，从以往经验看编码字符串出现有"u"，它是unicode编码，那么Escape编码采用是那一种unicode实现形式呢。其实是UTF-16BE模式。这样一来问题非常简单了。 <b>Escape编码/加密</b>,就是字符对应UTF-16 16进制表示方式前面加%u。<b>Unescape解码/解密</b>，就是去掉"%u"后，将16进制字符还原后，由utf-16转码到自己目标字符。如：字符“中”，UTF-16BE是：“6d93”，因此Escape是“%u6d93”，反之也一样！因为目前%字符，常用作URL编码，所以%u这样编码已经逐渐被废弃了！<br>基本类型只对汉字进行编码，复杂类型是所有字符均可</p><p><a href="(http://web.chacuo.net/charsetescape/)">加解密网站</a></p><h2 id="URL、Hex编码"><a href="#URL、Hex编码" class="headerlink" title="URL、Hex编码"></a>URL、Hex编码</h2><p><b>这两种加密的密文是一样的，不同的是当你用url编码网站时是不会把http进行编码的，而Hex编码则全部转化了</b></p>encodeURIComponent() 函数 与 encodeURI() 函数的区别 请注意 encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。<ul>    <li><a href="https://www.107000.com/T-Hex">hex</li>    <li><a href="https://www.sojson.com/encodeurl.html">URL</li></ul><h2 id="凯撒密码、维吉尼亚密码、栅栏密码基础型、栅栏密码W型"><a href="#凯撒密码、维吉尼亚密码、栅栏密码基础型、栅栏密码W型" class="headerlink" title="凯撒密码、维吉尼亚密码、栅栏密码基础型、栅栏密码W型"></a>凯撒密码、维吉尼亚密码、栅栏密码基础型、栅栏密码W型</h2><p>这几类密码原理都是移位调换加密，破解难度低</p><h3 id="1、凯撒密码——示例iodj-khoor-zrug-123"><a href="#1、凯撒密码——示例iodj-khoor-zrug-123" class="headerlink" title="1、凯撒密码——示例iodj{khoor_zrug_123}"></a>1、凯撒密码——示例<code>iodj&#123;khoor_zrug_123&#125;</code></h3><p><strong>只对字母进行加密，常用于CTF比赛中</strong></p><p>凯撒密码最早由古罗马军事统帅盖乌斯·尤利乌斯·凯撒在军队中用来传递加密信息，故称凯撒密码。此为一种位移加密手段，只对26个（大小写）字母进行位移加密，规则相当简单，容易被破解。下面是明文字母表移回3位的对比： 明文字母表 X Y Z A B C D E F G H I J K L M N O P Q R S T U V W 密文字母表 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 然后A变成D，B变成E，Z变成C。 字母最多可移动25位（按字母表）。通常为向后移动，如果您想向前移动1位，则相当于向后移动25位，位移选择为25位。</p><h3 id="2、维吉尼亚密码——示例fmcg-iglmq-wptd-123"><a href="#2、维吉尼亚密码——示例fmcg-iglmq-wptd-123" class="headerlink" title="2、维吉尼亚密码——示例fmcg{iglmq_wptd_123}"></a>2、维吉尼亚密码——示例<code>fmcg&#123;iglmq_wptd_123&#125;</code></h3><p><strong>可以说是凯撒密码的加强版，引入了密钥</strong></p><p>维吉尼亚密码，它将凯撒密码的所有26种排列放到一个表中，形成26行26列的加密字母表。此外，维吉尼亚密码必须有一个由字母组成的密钥，至少有一个字母，最多与明文字母有相同数量的字母。 在凯撒密码中，每个字母都会进行一定偏移值转换，例如，当偏移值是3时，则B被转换为E，C转换成F…。在维吉尼亚密码加密中，则是由具有不同偏移的凯撒密码构成的。 要生成密码，需要使用表格方法，此表(如图所示)包含26行字母表，每一行从上一行到左行被一位偏移。加密时使用哪一行字母表是基于密钥的，在加密过程中密钥会不断变化。 例如，假设明文为： BTTACKATDAFG 选择一个关键字并重复它以获得密钥，例如，当关键字是LIMN时，键是： LIMNLIMNLIMN 在明文中的第一个字母B，对应于密钥中的第一个字母L，使用加密字母表中的L行字母进行加密，得到第一个字母的密文M。同样，第二个明文字母是T，它用表中的I行加密，得到第二个密文B。通过类比，我们可以得到： 明文：BTTACKATDAFG 键：LIMNLIMNLIMN 密文：MBFNNSMGOIRT 解密的过程是加密的逆过程。例如，密钥的第一个字母对应的L行字母表，发现密文的第一个字母M位于B列，因此明文的第一个字母是B。密钥的第二个字母对应于I行字母表，而密文的第二个字母B位于该行的T列中，因此明文的第二个字母是T。等等，你可以得到明文。</p><h3 id="3、栅栏密码基础型"><a href="#3、栅栏密码基础型" class="headerlink" title="3、栅栏密码基础型"></a>3、栅栏密码基础型</h3><p><strong>栅栏密码是按一定规则将明文内容互相调换了位置</strong></p><p>栅栏密码(Rail fence Cipher)基础型加密方式，是一种简单的移动字符位置的加密方法，首先把加密的明文分成N个一组，然后把每组的第1、第2、第M个字符连起来，形成无规律的密文字符串。</p><p>例如字符串“123456789abc”，首先将字符串分成3组，如下排列： 1234 5678 9abc 依次取每一组字符，组成加密后密文：“15926a37b48c”。</p><h3 id="4、栅栏密码W型"><a href="#4、栅栏密码W型" class="headerlink" title="4、栅栏密码W型"></a>4、栅栏密码W型</h3><p>栅栏密码W型加密算法： 栅栏密码(Rail fence Cipher)，扩展变种W型，采用先把明文类似”W”形状进行排列，然后再按栏目顺序1-N，取每一栏的所有字符值，组成加密后密文。 比如字符串“123456789”，采用栏目数为3的时，明文将采用如下排列： 1—5—9 -2-4-6-8- –3—-7– 取每一栏所有字符串，组成加密后密文：“159246837”。 W型栅栏密码加密方式，比传统型栅栏密码加密方法，算法略有增强，但目前已只能用于学习算法验证。</p><ul>    <li><a href="https://www.qqxiuzi.cn/bianma/kaisamima.php">Caesar</a></li>    <li><a href="http://www.metools.info/code/c71.html">Virginia</a></li>    <li><a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php">栅栏密码</li>    <li><a href="http://www.atoolbox.net/Tool.php?Id=777">栅栏密码w</li></ul><h2 id="文本隐藏加密、零宽隐写"><a href="#文本隐藏加密、零宽隐写" class="headerlink" title="文本隐藏加密、零宽隐写"></a>文本隐藏加密、零宽隐写</h2><h3 id="1、文本隐藏加密"><a href="#1、文本隐藏加密" class="headerlink" title="1、文本隐藏加密"></a>1、文本隐藏加密</h3><p><strong>特征：加密过的密文会比原文的字节数多，当你按删除键的时候会发现某一处要按好多下才能把前面的字删掉</strong></p><p>原理：它的原理是在密文中加入了不可见字符组成的编码，例如上述看似九个字符的一句话，通过<a href="https://www.qqxiuzi.cn/zh/zishu-zijieshu/">字数查询</a>可知它实际上有87个字符，多出的字符是由<a href="https://www.qqxiuzi.cn/zh/space.html">零宽空格</a>实现的编码，因为零宽空格不占据空间，所以看不出它的存在。</p><p><strong>使用</strong>：在进行文本隐藏加密时，将需要隐藏的文字写在括号中，就像这样“你好（有才华），我好喜欢你（画的画）！”，然后加密即可隐藏括号内的文字。同时可以设定一个密码，这样只有知道密码的人才能解密隐藏的文字。密码可以是数字、字母和下划线，最多九位。</p><h3 id="2、零宽隐写"><a href="#2、零宽隐写" class="headerlink" title="2、零宽隐写"></a>2、零宽隐写</h3><p><strong>特征：解密后明文与密文会分开显示，密文一般隐藏在第一个字后面，不信你试试，保证你十下之内删不完</strong></p><p>与上面文本隐藏加密的原理一样，但过程不一样</p><ul>    <li><a href="https://www.qqxiuzi.cn/bianma/yincangjiami.php">文本隐写</a></li>    <li><a href="https://yuanfux.github.io/zero-width-web/">零宽隐写</a></li></ul><h2 id="特殊暗号类加密"><a href="#特殊暗号类加密" class="headerlink" title="特殊暗号类加密"></a>特殊暗号类加密</h2><p>这类加密都是特征性比较强的，易辨别</p><h3 id="1、猪圈密码"><a href="#1、猪圈密码" class="headerlink" title="1、猪圈密码"></a>1、猪圈密码</h3><p><strong>特点：只能对字母加解密并且符号无法复制，粘贴后会直接显示明文</strong></p><p>猪圈密码（亦称朱高密码、共济会暗号、共济会密码或共济会员密码），是一种以格子为基础的简单替代式密码，曾经是美国内战时盟军使用的密码，目前仅在密码教学、各种竞赛中使用。</p><p><img src="/img/blog/pighole.PNG"></p><h3 id="2、与佛论禅"><a href="#2、与佛论禅" class="headerlink" title="2、与佛论禅"></a>2、与佛论禅</h3><p><strong>特点：就是你看不懂的佛语</strong></p><p>被折磨的过根本不用任何辨识哈哈哈</p><h3 id="3、百家姓暗号"><a href="#3、百家姓暗号" class="headerlink" title="3、百家姓暗号"></a>3、百家姓暗号</h3><p><strong>特征：不要多说当你看到一串百家姓的时候多半就是这个暗号了</strong></p><h3 id="4、卡尔达诺栅格码"><a href="#4、卡尔达诺栅格码" class="headerlink" title="4、卡尔达诺栅格码"></a>4、卡尔达诺栅格码</h3><p><strong>特征：把明文伪装成垃圾邮件</strong></p><p><a href="https://www.spammimic.com/">加密解密</a></p><h3 id="5、莫尔斯电码"><a href="#5、莫尔斯电码" class="headerlink" title="5、莫尔斯电码"></a>5、莫尔斯电码</h3><p>这个也很有辨识度</p><h3 id="6、Quoted-Printable"><a href="#6、Quoted-Printable" class="headerlink" title="6、Quoted-Printable"></a>6、Quoted-Printable</h3><p><strong>这种编码常用与邮件处理，只能对汉字进行编码，特征是&#x3D;加两个大写字母或数字组合</strong></p><p><a href="https://dencode.com/string/quoted-printable">加密解密</a></p><p><img src="/img/blog/quoted-printable.PNG"></p><h3 id="7、ROT13"><a href="#7、ROT13" class="headerlink" title="7、ROT13"></a>7、ROT13</h3><p><strong>特征：它与凯撒密码差不多都是字母替换，你看到一句特别奇怪的语句可能就是它编码的</strong></p><p>ROT13（回转13位，Template:lang，有时中间加了个减号称作ROT-13）是一种简易的置换暗码。它是一种在网路论坛用作隐藏八卦（spoiler）、妙句、谜题解答以及某些脏话的工具，目的是逃过版主或管理员的匆匆一瞥。 ROT13被描述成「杂志字谜上下颠倒解答的Usenet对等体」（Usenet equivalent of a magazine printing the answer to a quiz upside down.）Template:cite web ROT13也是过去在古罗马开发的凯撒加密的一种变体。</p><h3 id="8、文本加密为汉字"><a href="#8、文本加密为汉字" class="headerlink" title="8、文本加密为汉字"></a>8、文本加密为汉字</h3><p><strong>特征：将明文加密成各种繁体字后面带俩等号</strong></p><h2 id="js专用加密"><a href="#js专用加密" class="headerlink" title="js专用加密"></a>js专用加密</h2><p>也是辨识度极为明显</p><h3 id="1、颜文字js加密"><a href="#1、颜文字js加密" class="headerlink" title="1、颜文字js加密"></a>1、颜文字js加密</h3><p><strong>特征：一堆颜文字构成的js代码，在F12中可直接解密执行</strong></p><h3 id="2、jother编码"><a href="#2、jother编码" class="headerlink" title="2、jother编码"></a>2、jother编码</h3><p><strong>特征：只用<code>! + ( ) [ ] &#123; &#125;</code>这八个字符就能完成对任意字符串的编码。也可在F12中解密执行</strong></p><h3 id="3、JSFuck编码"><a href="#3、JSFuck编码" class="headerlink" title="3、JSFuck编码"></a>3、JSFuck编码</h3><p><strong>特征：与jother很像，只是少了<code>&#123; &#125;</code></strong></p><p>hello <a href="http://example.com/2022/04/13/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%86%E6%96%87%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/">http://example.com/2022/04/13/加密编码类型的密文特征分析/</a> bye</p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>encryption</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
